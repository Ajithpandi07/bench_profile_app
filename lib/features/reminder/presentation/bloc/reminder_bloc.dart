import 'package:flutter_bloc/flutter_bloc.dart';
import 'reminder_event.dart';
import 'reminder_state.dart';
import '../../domain/repositories/reminder_repository.dart';
import '../../domain/entities/reminder.dart';

import '../../../../core/services/notification_service.dart';

class ReminderBloc extends Bloc<ReminderEvent, ReminderState> {
  final ReminderRepository _repository;
  final NotificationService _notificationService;
  DateTime? _currentSelectedDate;
  List<Reminder>? _cachedAllReminders;

  ReminderBloc({
    required ReminderRepository repository,
    required NotificationService notificationService,
  }) : _repository = repository,
       _notificationService = notificationService,
       super(ReminderInitial()) {
    on<LoadReminders>(_onLoadReminders);
    on<AddReminder>(_onAddReminder);
    on<UpdateReminder>(_onUpdateReminder);
    on<DeleteReminder>(_onDeleteReminder);
    on<RescheduleAllNotifications>(_onRescheduleAllNotifications);
  }

  Future<void> _onLoadReminders(
    LoadReminders event,
    Emitter<ReminderState> emit,
  ) async {
    emit(ReminderLoading());
    try {
      if (event.selectedDate != null) {
        _currentSelectedDate = event.selectedDate;
      }

      List<Reminder> allReminders;
      if (_cachedAllReminders != null && !event.forceRefresh) {
        allReminders = _cachedAllReminders!;
      } else {
        allReminders = await _repository.getReminders();
        _cachedAllReminders = allReminders;
      }

      if (_currentSelectedDate == null) {
        emit(ReminderLoaded(allReminders));
        return;
      }

      final selectedDate = DateTime(
        _currentSelectedDate!.year,
        _currentSelectedDate!.month,
        _currentSelectedDate!.day,
      );

      final filteredReminders = allReminders.where((reminder) {
        final start = DateTime(
          reminder.startDate.year,
          reminder.startDate.month,
          reminder.startDate.day,
        );
        final end = DateTime(
          reminder.endDate.year,
          reminder.endDate.month,
          reminder.endDate.day,
        );

        // Check if selected date is within the range [startDate, endDate]
        if (selectedDate.isBefore(start) || selectedDate.isAfter(end)) {
          return false;
        }

        switch (reminder.scheduleType) {
          case 'Daily':
            return true;
          case 'Weekly':
            if (reminder.daysOfWeek == null || reminder.daysOfWeek!.isEmpty) {
              return true; // Assume all days if not specified
            }
            return reminder.daysOfWeek!.contains(selectedDate.weekday);
          case 'Monthly':
            if (reminder.dayOfMonth == null) return false;
            return selectedDate.day == reminder.dayOfMonth;
          case 'As needed':
            return true;
          case 'Custom':
            if (reminder.customFrequency == null || reminder.interval == null)
              return true;

            final diff = selectedDate.difference(start);
            if (diff.isNegative) return false;

            if (reminder.customFrequency == 'Days') {
              return diff.inDays % reminder.interval! == 0;
            } else if (reminder.customFrequency == 'Weeks') {
              final weekDiff = (diff.inDays / 7).floor();
              if (weekDiff % reminder.interval! != 0) return false;
              if (reminder.daysOfWeek == null || reminder.daysOfWeek!.isEmpty)
                return true;
              return reminder.daysOfWeek!.contains(selectedDate.weekday);
            } else if (reminder.customFrequency == 'Months') {
              final monthDiff =
                  (selectedDate.year - start.year) * 12 +
                  selectedDate.month -
                  start.month;
              if (monthDiff % reminder.interval! != 0) return false;
              if (reminder.dayOfMonth != null) {
                return selectedDate.day == reminder.dayOfMonth!;
              }
              // If no day of month set, maybe fallback to start date's day?
              return selectedDate.day == start.day;
            }
            return true;
          default:
            return true;
        }
      }).toList();

      emit(ReminderLoaded(filteredReminders));
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onAddReminder(
    AddReminder event,
    Emitter<ReminderState> emit,
  ) async {
    try {
      final reminder = Reminder(
        id: '', // ID generated by backend
        name: event.name,
        category: event.category,
        quantity: event.quantity,
        unit: event.unit,
        scheduleType: event.scheduleType,
        daysOfWeek: event.daysOfWeek,
        dayOfMonth: event.dayOfMonth,
        time: event.time,
        startDate: event.startDate,
        endDate: event.endDate,
        smartReminder: event.smartReminder,
        interval: event.interval,
        customFrequency: event.customFrequency,
        recurrenceEndType: event.recurrenceEndType,
        recurrenceCount: event.recurrenceCount,
      );
      final id = await _repository.addReminder(reminder);

      // Schedule notification
      await _scheduleNotification(reminder.copyWith(id: id));

      emit(const ReminderOperationSuccess('Reminder added successfully'));

      // Small delay to ensure the BlocListener catches the success state
      await Future.delayed(const Duration(milliseconds: 100));

      add(const LoadReminders(forceRefresh: true));
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onUpdateReminder(
    UpdateReminder event,
    Emitter<ReminderState> emit,
  ) async {
    try {
      final reminder = Reminder(
        id: event.id,
        name: event.name,
        category: event.category,
        quantity: event.quantity,
        unit: event.unit,
        scheduleType: event.scheduleType,
        daysOfWeek: event.daysOfWeek,
        dayOfMonth: event.dayOfMonth,
        time: event.time,
        startDate: event.startDate,
        endDate: event.endDate,
        smartReminder: event.smartReminder,
        interval: event.interval,
        customFrequency: event.customFrequency,
        recurrenceEndType: event.recurrenceEndType,
        recurrenceCount: event.recurrenceCount,
      );
      await _repository.updateReminder(reminder);

      // Cancel old and schedule new
      await _notificationService.cancelNotification(event.id.hashCode);
      await _scheduleNotification(reminder);

      emit(const ReminderOperationSuccess('Reminder updated successfully'));

      // Small delay to ensure the BlocListener catches the success state
      await Future.delayed(const Duration(milliseconds: 100));

      add(const LoadReminders(forceRefresh: true));
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onDeleteReminder(
    DeleteReminder event,
    Emitter<ReminderState> emit,
  ) async {
    print('DEBUG BLOC: _onDeleteReminder called with ID: ${event.id}');
    try {
      print('DEBUG BLOC: Calling repository.deleteReminder');
      await _repository.deleteReminder(event.id);
      await _notificationService.cancelNotification(event.id.hashCode);
      emit(const ReminderOperationSuccess('Reminder deleted successfully'));

      // Small delay to ensure the BlocListener catches the success state
      await Future.delayed(const Duration(milliseconds: 100));

      add(const LoadReminders(forceRefresh: true));
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onRescheduleAllNotifications(
    RescheduleAllNotifications event,
    Emitter<ReminderState> emit,
  ) async {
    try {
      // 1. Cancel all existing notifications to match current DB state
      // (Optional, but safer to avoid ghosts if IDs changed or deletions happened outside)
      await _notificationService.cancelAll();

      // 2. Fetch all reminders
      final reminders = await _repository.getReminders();

      // 3. Schedule each valid reminder
      for (final reminder in reminders) {
        if (reminder.endDate.isAfter(DateTime.now())) {
          await _scheduleNotification(reminder);
        }
      }

      // 4. Update cache/state if needed, though this might be background
      // If the UI is listening, we might want to refresh the list too
      add(const LoadReminders(forceRefresh: true));
    } catch (e) {
      // Log error or emit state, but this might run in background/startup
      print('Failed to reschedule all notifications: $e');
    }
  }

  Future<void> _scheduleNotification(Reminder reminder) async {
    if (reminder.time == null || reminder.time!.isEmpty) return;

    // Parse time string "HH:mm"
    final parts = reminder.time!.split(':');
    if (parts.length != 2) return;
    final hour = int.tryParse(parts[0]);
    final minute = int.tryParse(parts[1]);
    if (hour == null || minute == null) return;

    print('DEBUG: Bloc Scheduling - Parsed Time: $hour:$minute');

    // Create a base date using start date + time
    final scheduledDate = DateTime(
      reminder.startDate.year,
      reminder.startDate.month,
      reminder.startDate.day,
      hour,
      minute,
    );

    await _notificationService.scheduleReminder(
      id: reminder.id.hashCode,
      title: 'Time to take ${reminder.name}',
      body: '${reminder.quantity} ${reminder.unit}',
      scheduledDate: scheduledDate,
      scheduleType: reminder.scheduleType,
    );
  }
}
