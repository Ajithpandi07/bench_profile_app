import 'package:flutter_bloc/flutter_bloc.dart';
import 'reminder_event.dart';
import 'reminder_state.dart';
import '../../domain/repositories/reminder_repository.dart';
import '../../domain/entities/reminder.dart';

class ReminderBloc extends Bloc<ReminderEvent, ReminderState> {
  final ReminderRepository _repository;
  DateTime? _currentSelectedDate;

  ReminderBloc({required ReminderRepository repository})
      : _repository = repository,
        super(ReminderInitial()) {
    on<LoadReminders>(_onLoadReminders);
    on<AddReminder>(_onAddReminder);
    on<UpdateReminder>(_onUpdateReminder);
    on<DeleteReminder>(_onDeleteReminder);
  }

  Future<void> _onLoadReminders(
      LoadReminders event, Emitter<ReminderState> emit) async {
    emit(ReminderLoading());
    try {
      final allReminders = await _repository.getReminders();

      if (event.selectedDate != null) {
        _currentSelectedDate = event.selectedDate;
      }

      if (_currentSelectedDate == null) {
        emit(ReminderLoaded(allReminders));
        return;
      }

      final selectedDate = DateTime(
        _currentSelectedDate!.year,
        _currentSelectedDate!.month,
        _currentSelectedDate!.day,
      );

      final filteredReminders = allReminders.where((reminder) {
        final start = DateTime(
          reminder.startDate.year,
          reminder.startDate.month,
          reminder.startDate.day,
        );
        final end = DateTime(
          reminder.endDate.year,
          reminder.endDate.month,
          reminder.endDate.day,
        );

        // Check if selected date is within the range [startDate, endDate]
        if (selectedDate.isBefore(start) || selectedDate.isAfter(end)) {
          return false;
        }

        switch (reminder.scheduleType) {
          case 'Daily':
            return true;
          case 'Weekly':
            if (reminder.daysOfWeek == null || reminder.daysOfWeek!.isEmpty) {
              return true; // Assume all days if not specified, or handle as error? defaulting to true
            }
            // dataValues logic from set_schedule_step:
            // 1=Mon, ..., 7=Sun.
            // DateTime.weekday: 1=Mon, ..., 7=Sun.
            // But wait, the previous code had a specific mapping for the UI:
            // final dayValues = [7, 1, 2, 3, 4, 5, 6]; -> S, M, T, W, T, F, S
            // So 7 is Sunday, 1 is Monday.
            // specific mapping check:
            // database stores: [7, 1, 2] etc.
            // selectedDate.weekday gives 1-7 (Mon-Sun).
            return reminder.daysOfWeek!.contains(selectedDate.weekday);
          case 'Monthly':
            if (reminder.dayOfMonth == null) return false;
            return selectedDate.day == reminder.dayOfMonth;
          case 'As needed':
            // 'As needed' might technically be always visible or only on start date?
            // Usually 'As needed' implies no specific schedule, but if valid in range, maybe show it?
            // For now, let's assume it shows if within range.
            return true;
          default:
            return true;
        }
      }).toList();

      emit(ReminderLoaded(filteredReminders));
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onAddReminder(
      AddReminder event, Emitter<ReminderState> emit) async {
    try {
      final reminder = Reminder(
        id: '', // ID generated by backend
        name: event.name,
        category: event.category,
        quantity: event.quantity,
        unit: event.unit,
        scheduleType: event.scheduleType,
        daysOfWeek: event.daysOfWeek,
        dayOfMonth: event.dayOfMonth,
        time: event.time,
        startDate: event.startDate,
        endDate: event.endDate,
        smartReminder: event.smartReminder,
      );
      await _repository.addReminder(reminder);
      add(LoadReminders());
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onUpdateReminder(
      UpdateReminder event, Emitter<ReminderState> emit) async {
    try {
      final reminder = Reminder(
        id: event.id,
        name: event.name,
        category: event.category,
        quantity: event.quantity,
        unit: event.unit,
        scheduleType: event.scheduleType,
        daysOfWeek: event.daysOfWeek,
        dayOfMonth: event.dayOfMonth,
        time: event.time,
        startDate: event.startDate,
        endDate: event.endDate,
        smartReminder: event.smartReminder,
      );
      await _repository.updateReminder(reminder);
      add(LoadReminders());
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }

  Future<void> _onDeleteReminder(
      DeleteReminder event, Emitter<ReminderState> emit) async {
    try {
      await _repository.deleteReminder(event.id);
      add(LoadReminders());
    } catch (e) {
      emit(ReminderError(e.toString()));
    }
  }
}
